# 1. 메모리란

- 메모리란 **CPU에 의하여 시행될 프로그램이 저장**되는 곳
- 메모리에는 레지스터, 캐시 기억장치, 주기억장치, 보조기억장치가 해당된다.
- 위의 기억장치들은 계층 구조로 분류할 수 있다.
>💡 컴퓨터 시스템의 메모리 계층을 나누어서 사용하는 이유는 입출력의 경제성 때문이다.

<br />

## 01. 메모리 종류
### 1. 주기억장치(Main Memory Unit)
- `RAM`(Random Access Memory)
  - 캐시메모리 보다 비교적 대용량
  - 고속의 속도
  - 휘발성 성질
  - 읽기/쓰기 모두 가능
>💡 RAM은 임의 액세스 방식을 이용하는 반도체 기억장치이며, 모든 동작들은 `전기적인 신호`들을 이용하여 이루어 진다.
- `ROM`(Read Only Memory)
  - 비휘발성
  - **읽기만 가능**한 주기억장치의 일종 
>💡 ROM이 비휘발성 메모리로 데이터가 영구저장 될 수 있었던 이유는, 데이터를 저장함에 있어서 전류에 의존하지 않고, **바이너리 코드를 사용**해 개별 셀에 쓰이기 때문이다.<br />
그렇기 때문에, ROM은 소프트웨어 초기 부팅 관련, 펌웨어 명령, 제어 유니트의 마이크로프로그램, 빈번히 사용되는 함수들과 서브루틴 등 변하지 않는 부품에 사용된다.
- `캐시 메모리`(Cache memory)
  - CPU와 주기억장치의 속도차이를 보완하기 위해 CPU에 인접하게 설치하거나 혹은 칩 내부에 포함되는 반도체 기억장치
>💡 캐시 메모리에는 한 번 이상 사용된 현재 진행되고 있는 프로그램의 일부 또는 사용빈도가 높은 임시 데이터들을 저장한다.

<br />

### 2. 보조기억장치(Auxiliary Memory Unit)
- 주기억장치에 비해서 **비교적 속도가 느리다**
- **비트당 가격이 낮아 대용량**으로 사용이 가능하고, 영구저장이 가능하다.
- HDD, SSD, USB, 플로피디스크, SD card, 플래시메모리카드 등이 해당된다.
- CPU가 직접 접근할 수 없기 때문에, 주기억장치에 필요한경우 Loading 후 접근해야 한다.
<br /><br />
# 2.기억장치 계층 구조와 특징
![Memory 계층구조](https://media.vlpt.us/images/jgone2/post/5097e3af-f64e-4e9f-b990-bfa9e084f4a0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-01-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2010.48.49.png)<br />
- 계층 구조에서 상위의 기억장치일수록 접근 속도와 접근 시간이 빠르다.
- 상위의 기억장치일수록 기억용량은 적고 비트당 가격은 높아진다.
- 주기억장치는 각각 자신의 주소를 갖는 `워드(word) 또는 바이트(Byte)`들로 구성되어 있다.
- 주기억 장치에 엑세스하기 위해서는 `각 워드의 주소`를 이용한다.
- 레지스터, 캐시 기억장치, 주기억장치는 `내부 기억장치`에 해당되고, 보조 기억장치는 `외부 기억장치`에 해당한다.
- 내부 기억장치의 프로그램과 데이터는 `CPU가 직접 엑세스` 할 수 있다.
- 외부 기억장치에는 직접 `액세스 할 수 없다.`
- 외부 기억장치에 있는 데이터는 `주기억장치에 적재된 후` CPU에 의해 액세스될 수 있다.
<br /><br />

# 3. 메모리 관리의 개요
메모리는 반도체 하드웨어로, 데이터를 저장하는 저장장치의 역할을 수행한다. CPU에서 직접적인 접근이 가능하고, 읽거나 쓰는 속도가 빠르다.<br /> 하지만 휘발성의 특성을 가지고있고 주기억장치들은 비트당 가격이 높고 용량이 **한정적**이기 때문에 프로세스가 필요한 메모리를 언제 얼마만큼 **할당**해 줄 것인지는 매우 중요하다. 또한 어떻게 **접근**하도록 할 것인가도 메모리관리에서 중요하다.
<br /><br />

# 4. 주소 바인딩(Address Binding)
프로세스를 실행하기 위해서 CPU에 의해 각각의 프로세스가 메모리에 할당되어야한다. 이때 CPU는 메모리에 적제된 프로세스의**논리적 주소(Logical Address)를 참조**하게된다. <br />
이때, **논리적 주소를 물리적 메모리 주소로 연결**시켜주는 작업을 말한다.
>`논리적 주소`: 가상 주소로 각 프로세스마다 독립적으로 할당되는 공간<br />
`물리적 주소`: 실제 물리 메모리에 적재되는 위치를 식별할 수 있는 주소

프로그램이 적재되는 **물리적 메모리의 주소가 언제 결정**되느냐에 따라 세가지 바인딩 방식이 있다.<br/>
![바인딩](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FwB1HA%2FbtqNWFAvKUa%2FBkaqT4QxbUYZ8xDFFy3kvk%2Fimg.jpg)<br />
### 01. 컴파일(Compile) 타임 바인딩
- 컴파일 시 물리적 메모리 주소가 결정되는 방식으로, 실행 파일에 물리 주소를 포함
- 프로그램 내부에서 사용하는 주소와 물리적 메모리 주소가 동일. 
- 프로세스의 물리적 주소를 변경하고 싶으면 컴파일을 재실행 해야한다.
- 멀티 프로세스환경에서 사용하기 힘듦
### 02. 로드(Load) 타임 바인딩
- 프로그램 실행이 시작될 때 물리적 메모리 주소가 결정되는 방식
- `로더(Loader)`가 메모리 주소를 부여하며, 프로그램이 종료될 때까지 물리적 메모리 주소가 고정된다.
- 메모리를 참조하는 명령어를 모두 변경해야하기 때문에, 로딩 시간이 매우 오래 걸림.
>💡 loader: 사용자 프로그램을 메모리에 적재시키는 프로그램
### 03. 실행(Excution) 시간 바인딩
- 프로그램을 실행한 뒤에도 프로그램이 위치한 **물리적 메모리상의 주소가 변경**될 수 있는 방식
- CPU가 주소를 참조할 때마다 주소 매핑 테이블을 확인.
- MMU(Memory Management Unit)의 도움이 필요
<br /><br />

# 5. 메모리 관리 장치(Memory Management Unit, MMU)
![MMU](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdGS2qq%2FbtqAJwDhpJK%2FoPVkHdYvn3aSi7PL7luuZ1%2Fimg.png)<br />
- 프로세스의 논리 주소에 재배치 레지스터 값을 더함으로써 실제 메모리의 물리 주소로 변환하는 역할을 수행
- 재배치 레지스터를 사용함으로써 물리 주소는 실행 중에 얼마든지 변경될 수 있다.

# 6. 메모리 관리 전략
모든 프로그램을 실행하기 위해서는 메모리에 적재되어야 실행이 가능하다. 하지만 메모리는 **한정된 자원**이기 때문에 여러 프로세스가 함께 **효율적으로 사용하기 위한 방법이 필요**하며, 메모리 관리를 위한 전략에는 반입(Fetch)전략, 배치(Placement)전략, 교체(Replacement)전략이 있다.

### 01. 반입(Fetch)전략
반입 전략은 보조기억장치에 보관중인 프로그램이나 데이터를 **언제** 주기억장치로 적재할 것인지를 결정하는 전략이다.
- `요구 반입`(Demand Fetch)
  - 실행중인 프로그램이 특정 프로그램이나 데이터 등의 **참조를 요구할 때** 적재하는 방법
- `예상 반입`(Anticipatory Fetch)
  - 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 **미리 예상**하여 적재하는 방법

### 02. 배치(Placement)전략
배치 전략은 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략이다.

- `최초 적합`(First Fit)
  - 가용 공간 중에서 **첫 번째 분할 영역**에 배치시키는 방법
  - 검색 속도가 빠르다.
- `최적 적합`(Beset Fit)
  - 가용 공간 중에서 **8가장 작은 분할 영역**에 배치시키는 방법
  - 분할되어 남는 가용 공간의 크기를 최소화한다.
- `최악 적합`(Worst Fit)
  - 가용 공간 중에서 **가장 큰 분할 영역**에 배치시키는 방법
  - 검색 속도 느려지고 메모리 효율이 좋지 않다.

### 03. 교체(Replacement)전략
교체 전략은 현재 주기억장치에 **적재된 프로세스 중 제거할 프로세스를 결정**하는 전략이다.<br />
종류로는 FIFO, OPT, LRU, LFU 등이 있다.
<br /><br />

# 7. 단편화
동적 메모리 할당에서 분할된 영역에 프로그램이나 데이터를 할당하면 **메모리의 낭비되는 영역**이발생하게 되는데 이를 단편화라고 한다.

## 01. 내부 단편화
분할된 메모리 영역이 할당될 프로그램이나 데이터의 크기보다 클 때 **할당 후 남은 메모리의 잉여 영역**이 남는 상황.

## 02. 외부 단편화
분할된 메모리 영역이 할당될 프로그램의 크기보다 작아 **총 가용공간은 충분하지만 분할되어있어 할당하지 못하는 상황**을 말한다.
<br /><br />

# 8. 스와핑(Swapping)
- 부족한 메모리 공간을 좀 더 효율적으로 관리하기위한 메모리 관리 기법.
- 준비상태 혹은 대기상태에 있는 프로세스들 중 일부를 backing store에 보관하는 것
- swapping을 통해 메모리 위의 프로세스에게 충분한 메모리 공간을 제공할 수 있다.
  - `swap in`: 메모리 적재
  - `swap out`: backing store로 이동<br />
![Swapping](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbjcOad%2FbtqAKiki52t%2FH1pMQi4JAo3QAdVaHqSVW1%2Fimg.png)<br />
>💡 backing store(=swap area): 디스크의 파일 시스템과 별도로 존재하는 일정 영역으로 프로세스가 수행중일 때 일시적으로 저장하는 공간으로 **보조기억장치**가 여기에 해당된다.

<br />

# 9. 연속 메모리 할당
각 프로세스가 하나의 연속된 메모리 공간에 포함된다. 각 프로세스가 필요로 하는 메모리 요구량을 미리 분석해서 결정해 놓고 그 프로세스의 메모리를 하나의 덩어리로 설정하여 실제 메모리에 할당하는 원리이다.

## 01. 동적 메모리 할당
정적 할당 기법의 단편화를 줄이기 위한 것으로, 미리 메모리를 분할해 놓는 것이 아니라 프로그램을 메모리에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법
>💡 정적 할당은 프로그램을 할당하기 전에 운영체제가 메모리의 사용자 영역을 여러 개의 고정된 크기로 분할 하는 기법
- 메모리를 효율적으로 사용할 수 있으며, 멀티 프로그래밍의 정도를 높일 수 있다.
- 정적 할당 기법에 비해 실행될 프로세스 크기에 대한 제약이 적다.
- 단편화를 상당 부분 해결할 수 있다.

# 10. 가상 메모리
가상메모리는 보조기억장치의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 큰 용량을 가진 것 처럼 사용하는 기법이다.
- 프로그램을 여러 개의 작은 블록단위로 나누어서 가상기억장치에 보관하고, 프로그램 실행 시 필요한 블록만 메모리에 불연속적으로 할당하여 처리
- 메모리 용량보다 큰 프로그램을 실행하기 위해 사용
- 메모리 이용률과 멀티 프로그래밍의 효율을 높일 수 있다.
- 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있다.
- 구현 방법에는 페이징 기법과 세그멘테이션 기법이 있다.

## 01. 페이징(Paging)기법
가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(Page)을 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법
- `Page`:  프로그램을 일정한 크기로 나눈 것
- `Page Frame`: 페이지 크기로 일정하게 나누어진 주기억장치의 단위
- 프레임 단위의 비연속적 메모리 할당으로 **외부 단편화가 없음**.
- 주소 변환을 위해 어떤 프레임에 저장이 되는지에 관한 위치 정보를 가지고 있는 **Page Table이 필요**하다.<br />
![Paging](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fs5fhI%2FbtqAKiruCgN%2FsIoPbQKljmrL0NfJ5eEMKk%2Fimg.png)<br />

## 02. 세그먼테이션(Segmentation)
서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할하여 프로그램을 적재 후 실행하는 기법
- 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 가상주소 형식에서 세그먼트번호를 나타내는 s와 실제 내용이 위치하는 위치까지의 거리를 나타내는 변위값 d로 구성된다.
- 서로 크기가 다른 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다보면, 가용공간이 많은 수의 작은 조각으로 나누어져 잉여공간이 될 수 있는 외부 단편화가 있음

<br /><br />

# 📚 Reference
[운영체제 21장-가상메모리-](https://copycode.tistory.com/113)<br />
[MMU란?](https://jhnyang.tistory.com/247)<br />
[7.메모리 관리](https://naruu098.tistory.com/25)<br />
[메모리 관리](https://velog.io/@goban/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC)<br />
[메모리 관리란?](https://technote-mezza.tistory.com/92)<br />
[메모리 관리 전략](https://sorjfkrh5078.tistory.com/48)<br />
[[CS 기초 - 운영체제] 메모리 관리 전략](https://velog.io/@deannn/CS-%EA%B8%B0%EC%B4%88-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5)<br />
[main memory: 주소 바인딩에 대해서](https://beyndlevel.tistory.com/35)<br />
[주소 바인딩](https://designjava.tistory.com/103)<br />
[[OS기초/메모리 관리] 주소 바인딩](https://velog.io/@adam2/OS%EA%B8%B0%EC%B4%88%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9)<br />
[페이징, 세그먼테이션](https://jinhyy.tistory.com/34?category=770230)<br />
[메모리 관리 기법 - 페이징, 세그멘테이션](https://goodmilktea.tistory.com/35?category=816729)<br />
